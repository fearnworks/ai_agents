from modules.base.llm_chain_config import LLMChainConfig
from modules.knowledge_retrieval.destination_chain import DestinationChainStrategy
from modules.knowledge_retrieval.base import KnowledgeDomain
from loguru import logger
from langchain import PromptTemplate, LLMChain
from langchain.llms.openai import OpenAI
from typing import Callable
import pprint 


class BusinessDomain(KnowledgeDomain):
    """
    BusinessDomain Class

    Design:
    This class extends the KnowledgeDomain class following the Open/Closed Principle (OCP) 
    and provides a specific implementation for generating responses to business-related questions. 
    Its single responsibility, as per the Single Responsibility Principle (SRP), is to generate 
    business-related responses.

    Intended Implementation:
    The generate_response method should be able to generate accurate and helpful responses to 
    business-related questions. The logic for generating these responses could be rule-based, 
    or it could use a trained machine learning model.
    """
    def generate_response(self, question: str) -> str:
        template_cot = """You are asked a business-related question and rather than simply guessing the right answer break down the solution into a series of steps
        The question is {question}

        Write out your step by step reasoning and after considering all of the facts and applying this reasoning write out your final answer
        """
        prompt = PromptTemplate(template=template_cot, input_variables=["question"])
        llm_chain = LLMChain(prompt=prompt, llm=OpenAI(temperature=0.7, max_tokens=1500))  # assuming OpenAI is the LLM to be used
        response_cot = llm_chain.run(question)
        return response_cot


class BusinessChain(DestinationChainStrategy):
    """
    BusinessChain Class

    Design:
    This class is a specific implementation of the ChainStrategy class.
    It follows the Open/Closed Principle (OCP) because it extends the ChainStrategy class 
    without modifying its behavior. It also adheres to the Dependency Inversion Principle (DIP) as it 
    depends on the abstraction (BusinessDomain) rather than a concrete class.

    Intended Implementation:
    The BusinessChain class serves as a wrapper around a BusinessDomain instance. It implements the run 
    method from the ChainStrategy class, which simply calls the generate_response method of the BusinessDomain.
    As such, when the run method is called with a question as input, the BusinessChain class will return a 
    response generated by the BusinessDomain. This response will be business-related, as the BusinessDomain is 
    designed to generate responses to business-related questions.
    """
    def __init__(self, config: LLMChainConfig, display: Callable):
        super().__init__(config=config, display=display, knowledge_domain=BusinessDomain(), usage=config.usage)
        print("Creating Business Chain with config: ")
        pprint.pprint(vars(config))

    def run(self, question):
        print('Using Business Chain of Thought')
        self.display("Using 'Business Chain of Thought'")
        response_cot = super().run(question)
        return response_cot

def get_business_chain_config(temperature: float = 0.7) -> LLMChainConfig:
    usage = """
    This problem is business-related and requires a business-related response or business data. In general this should be items related to the small family business.
    """
    return LLMChainConfig(usage=usage, temperature=temperature)
